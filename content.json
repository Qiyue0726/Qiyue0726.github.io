{"meta":{"title":"素晴らしい未来","subtitle":"素晴らしい","description":"","author":"凉月","url":"http://www.subarashii.top","root":"/"},"pages":[],"posts":[{"title":"SpringCloud微服务架构系列服务的注册发现与调用","slug":"SpringCloud微服务架构系列服务的注册发现与调用","date":"2019-08-27T14:50:08.000Z","updated":"2019-08-28T02:41:54.000Z","comments":true,"path":"2019/08/27/SpringCloud微服务架构系列服务的注册发现与调用/","link":"","permalink":"http://www.subarashii.top/2019/08/27/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B0%83%E7%94%A8/","excerpt":"","text":"简介众所周知，SpringCloud是一个微服务框架，本质上是基于SpringBoot的一整套实现微服务的框架。包含了服务发现、负载均衡、断路器、服务网关、分布式配置等组件。其中服务注册、发现又有Netflix的Eureka，阿里的Dubbo，Apache的Consul等，本篇文章将以Eureka进行讲解。 EurekaEureka是Netflix开发的服务发现框架，本身是一个基于REST的服务。由两个组件组成： Eureka Server：也被称作是服务注册中心，用于提供服务的注册与发现。 Eureka Client：包含服务消费者与服务生产者。 图片来源于互联网，如侵权可联系博主 Eureka的作用就是将我们定义的API接口注册到Eureka服务器上，方便管理，调用的时候只需要知道服务名就可以，不再通过IP加端口号的方式调用，利于解耦。 服务的注册与发现一、新建主项目 选择Maven，点击Next 填写相关信息，点击Next 确定信息无误后，点击Finish 将src文件夹删除（如果有的话）打开pom.xml文件，添加如下代码。 1234567891011121314151617181920212223&lt;!--必须指定该父模块，不然后面子模块启动会报错，很麻烦--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; &lt;!--父模块类型必须为pom--&gt;&lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--包含子模块--&gt;&lt;modules&gt; &lt;/modules&gt; &lt;!--在父模块添加web依赖，子模块可继承该依赖--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 二、新建Eureka Server 在项目上右键新建Module 选择Spring Initializr，点击Next，填写相关信息，Next 选择导入Eureka Server 依赖，Next，确认信息，点击Finish 打开Server模块的pom.xml文件，修改 &lt;parent&gt;标签 12345&lt;parent&gt; &lt;groupId&gt;org.sakura&lt;/groupId&gt; &lt;artifactId&gt;eureka&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 打开主模块的pom.xml文件，在&lt;modules&gt;标签添加相应的子模块 1234&lt;!--包含子模块--&gt;&lt;modules&gt; &lt;module&gt;Server&lt;/module&gt;&lt;/modules&gt; 将Server模块中的application.properties重命名为application.yml，并添加如下信息，也可直接使用properties文件类型（需修改如下代码） 1234567891011121314151617181920212223242526272829# Eureka 服务注册与发现的组件server: port: 8080spring: application: #服务名，很重要 name: servereureka: instance: hostname: localhost #将prefer-ip-address设为开启时，将默认显示服务的地址，而非主机名# prefer-ip-address: true #以IP地址注册到服务中心，相互注册使用IP地址# prefer-ip: 127.0.0.1 #显式设置服务的地址 client: # 下面两个 false 表明自己是 server，而非 client register-with-eureka: false # 不要使用 eureka 服务进行注册，即在管理界面不可见 fetch-registry: false # 不要在本地缓存注册表信息 service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/# defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka/ server: #开启自我保护模式 enable-self-preservation: false #清理无效节点,默认60*1000毫秒,即60秒 eviction-interval-timer-in-ms: 5000 修改Server模块的启动类，添加@EnableEurekaServer注解即可 123456789@EnableEurekaServer@SpringBootApplicationpublic class ServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServerApplication.class, args); &#125;&#125; 启动Server服务，打开http://localhost:8080 三、新建Eureka Client 新建Client模块，前两步和之前一样，只有导入依赖那里不一样 修改子父模块的pom.xml，与Server模块一样 修改application.yml 1234567891011121314151617181920server: port: 8081spring: application: # 服务名，很重要 name: clienteureka: instance: hostname: localhost #以IP地址注册到服务中心，相互注册使用IP地址# prefer-ip-address: true client: service-url: #服务注册地址 defaultZone: http://$&#123;eureka.instance.hostname&#125;:8080/eureka 修改启动类，添加@EnableEurekaClient注解（@EnableDiscoveryClient或不加都可以） 123456789@EnableEurekaClient@SpringBootApplicationpublic class Client1Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Client1Application.class, args); &#125;&#125; 启动Client服务（启动Client前，需保证Server正在运行，不然会报错），打开刚才的链接 可以看到，Client服务已经注册到服务中心了。这里可能有小伙伴会发现点击这个服务的链接是会出现404的，这是因为项目没有使用到Actuator。服务的调用SpringCloud有两种服务调用的方式 Ribbon Feign 一、Ribbon SpringCloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。几乎存在于每一个SpringCloud构建的微服务和基础设施中。因为微服务间的调用，API网关的请求转发等内容，实际上都是通过Ribbon来实现的。 再创建一个Client2服务，配置文件中除端口与之前的Client不同外，其它都一致，服务名也一样，这是为了实现负载均衡。 1234567891011121314151617server: port: 8082spring: application: name: clienteureka: instance: hostname: localhost #以IP地址注册到服务中心，相互注册使用IP地址 # prefer-ip-address: true client: service-url: #服务注册地址 defaultZone: http://$&#123;eureka.instance.hostname&#125;:8080/eureka 为两个Client各添加一个API接口 12345678@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String sayHello(@RequestParam(required = true,name = &quot;name&quot;) String name)&#123; return &quot;Hello &quot; + name + &quot;, 8081&quot;; &#125;&#125; 12345678@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String sayHello(@RequestParam(required = true,name = &quot;name&quot;) String name)&#123; return &quot;Hello &quot; + name + &quot;, 8082&quot;; &#125;&#125; 再新建一个Robbon模块，前面基本一样，依赖不同 修改配置文件和pom 1234567891011121314151617server: port: 8083spring: application: name: ribboneureka: instance: hostname: localhost #以IP地址注册到服务中心，相互注册使用IP地址 # prefer-ip-address: true client: service-url: #服务注册地址 defaultZone: http://$&#123;eureka.instance.hostname&#125;:8080/eureka 修改启动类，需添加一个RestTemplate bean 12345678910111213141516171819@EnableDiscoveryClient@SpringBootApplicationpublic class RibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125; /** * 负载均衡配置 * @return */ @Bean @LoadBalanced RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 在Ribbon模块中加入一个Service和一个Controller 12345678910@Servicepublic class HelloService &#123; @Autowired RestTemplate restTemplate; public String helloService(String name)&#123; return restTemplate.getForObject(&quot;http://client/hello?name=&quot;+name,String.class); &#125;&#125; 1234567891011@RestControllerpublic class HelloController &#123; @Autowired HelloService helloService; @GetMapping(&quot;/hello&quot;) public String hello(String name)&#123; return helloService.helloService(name); &#125;&#125; 依次启动Server模块和其它各模块 可以看到，两个Client和一个Ribbon都已经注册上去了 打开http://localhost:8083/hello?name=sakura 每次刷新调用的服务都不同，证明客户端负载均衡成功了 二、FeignFeign是基于Ribbon实现的工具，采用基于接口的注解 新建Feign模块，引入依赖 修改配置文件和pom 1234567891011121314151617server: port: 8084spring: application: name: feigneureka: instance: hostname: localhost #以IP地址注册到服务中心，相互注册使用IP地址 # prefer-ip-address: true client: service-url: #服务注册地址 defaultZone: http://$&#123;eureka.instance.hostname&#125;:8080/eureka 修改启动类，添加@EnableEurekaClient和@EnableFeignClients 12345678910@EnableFeignClients@EnableEurekaClient@SpringBootApplicationpublic class FeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignApplication.class, args); &#125;&#125; 创建一个Service接口 123456@FeignClient(value = &quot;client&quot;) //value值为需要调用的服务名public interface IFeignService &#123; @GetMapping(&quot;/hello&quot;) //这里的地址为需要调用的服务里相应的接口地址 String hello(@RequestParam(value = &quot;name&quot;)String name);&#125; 使用上面的接口（声明完上面Feign接口后，其他Spring管理的类，如Service、Controller都可以直接注入使用,IDEA可能会提示不能注入，可忽略） 1234567891011@RestControllerpublic class HelloController &#123; @Autowired private IFeignService iFeignService; @GetMapping(&quot;/feign/hello&quot;) public String sayHello(String name)&#123; return iFeignService.hello(name); &#125;&#125; 依次启动Server模块和Feign模块和Client模块 访问http://localhost:8084/feign/hello?name=sakura 以上相对全面简洁的介绍了SpringCloud中服务的注册、发现与调用。代码已上传至Github","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://www.subarashii.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.subarashii.top/tags/SpringCloud/"}]},{"title":"浅析常用设计模式创建型","slug":"浅析常用设计模式创建型","date":"2019-08-19T06:19:24.000Z","updated":"2019-08-19T13:26:59.000Z","comments":true,"path":"2019/08/19/浅析常用设计模式创建型/","link":"","permalink":"http://www.subarashii.top/2019/08/19/%E6%B5%85%E6%9E%90%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%9E%8B/","excerpt":"","text":"单例模式一. 概念单例模式是一种常见的设计模式。通过单例模式可以确保某个类有且仅有一个对象实例，能够自行实例化并向整个系统提供了这个实例。确保所有对象访问的都是同一个实例，避免对资源的多重占用，减少系统的性能开销。 注： Spring的bean默认为单例模式 二. 实现方法 将构造函数设置为私有，限制外部实例化该对象 提供一个getInstance方法返回内部创建的实例对象 三. 几种基本写法1. 饿汉式（线程安全）饿汉式是最简单的一种实现方式。它在类加载的时候就对对象进行实例，并在整个系统的生命周期中一直存在，避免了多线程同步的问题。不过即使系统自始至终都没有使用该对象时也会被创建，就会造成内存资源的浪费。 12345678910111213public class Singleton &#123; //私有化构造函数，使该类不会被实例化 private Singleton()&#123;&#125; //创建Singleton的一个对象实例 private static final Singleton instance = new Singleton(); //获取唯一可用的对象实例 public static Singleton getInstance()&#123; return instance; &#125;&#125; 2. 懒汉式（线程不安全）懒汉式是在系统需要时才会去创建，如果实例已经存在了，那么当再次调用获取实例的接口时将不会再次创建对象，而是直接返回之前创建的对象。但是这里的懒汉式没有考虑到线程安全的问题，在多线程下可能会并发调用它的getInstance()方法，导致创建多个对象实例。该模式适合单线程下使用。 12345678910111213public class Singleton &#123; private Singleton()&#123;&#125;; private static Singleton instance = null; public static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 3. 懒汉式（线程安全）为了解决懒汉式带来的线程安全问题，一般有三种解决办法 为getInstance()添加同步锁12345678910111213public class Singleton &#123; private Singleton()&#123;&#125;; private static Singleton instance = null; public static synchronized Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 缺点： 效率低下，第一次加载会稍慢，虽然解决了线程同步的问题，但是以后每次调用getInstance()方法都会进行同步，造成不必要的资源消耗。 双重检查1234567891011121314151617public class Singleton &#123; private Singleton()&#123;&#125;; private static Singleton instance = null; public static Singleton getInstance()&#123; if (instance == null)&#123; synchronized (Singleton.class)&#123; if (instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 优点： 资源利用率高，只有第一次调用getInstance()方法才会上锁并创建对象实例，以后每次调用都不再需要进行同步操作，减少了系统的开销。缺点： 第一次加载会稍慢。 这种写法的亮点主要是在getInstance()方法中进行双重的判断，第一层判断主要是为了避免不必要的同步，第二层判断则是为了实例为null时才去创建实例。 静态内部类12345678910111213public class Singleton &#123; private Singleton()&#123;&#125;; public static class SingletonHolder &#123; private static final Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 这是最推荐的一种书写方法，可以同时保证线程安全和懒汉式的延迟加载。 工厂模式工厂模式是在Java开发中最常用的一种实例化对象的设计模式，它大致可分为三类：简单工厂模式、工厂方法模式、抽象工厂模式 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 优点： 解耦。将对象的创建和使用分开，用户只需要知道工厂的名称就能得到具体的产品，无需知道产品的具体实现过程。 扩展性高。当需要增加新产品时，只需要添加一个具体的产品类和对应的工厂类即可，无需对原工厂进行任何修改，满足开闭原则。 缺点： 每增加一个新产品就要添加一个具体的产品类和对应的工厂类，增加系统的复杂度。 在面向对象编程领域中，开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的” 一. 简单工厂模式1. 概念简单工厂模式又称为静态工厂方法模式。它只有一个工厂类和一个产品抽象类，当新增一个产品时，就需要对工厂类进行修改。一个工厂可以生产多种产品。客户需要知道传入工厂类的参数，不关心产品如何生产。简单工厂模式并不是23种设计模式之一，只能算是工厂模式的一个特殊实现。因为它违背了开闭原则。 2. 角色类 抽象产品类。抽象一个产品基类（或接口），定义产品的某些特征。 具体产品类。继承抽象产品类，创建具体需要的产品的实例。 简单工厂类。简单工厂模式的核心，根据需求创建（调用）具体的产品对象。3.实例 *抽象产品类**1234567package SimpleFactory;public abstract class Product &#123; //描述产品的特征 public abstract void getInformation();&#125; *具体产品类A、B**12345678package SimpleFactory;public class ProductA extends Product &#123; public void getInformation() &#123; System.out.println(&quot;产品A&quot;); &#125;&#125; 12345678package SimpleFactory;public class ProductB extends Product &#123; public void getInformation() &#123; System.out.println(&quot;产品B&quot;); &#125;&#125; *简单工厂类**12345678910111213141516171819package SimpleFactory;public class Factory &#123; public static final int TYPE_A = 1; public static final int TYPE_B = 2; public static Product createProduct(int type) &#123; switch (type)&#123; case TYPE_A: return new ProductA(); case TYPE_B: return new ProductB(); default: System.out.println(&quot;没有该产品！&quot;); return null; &#125; &#125;&#125; *测试**1234567891011121314151617package SimpleFactory;public class Consumer &#123; public static void main (String args[]) &#123; Product productA = Factory.createProduct(&#x27;A&#x27;); productA.getInformation(); Product productB = Factory.createProduct(&#x27;B&#x27;); productB.getInformation(); //不存在C产品,会空指针报错 Product productC = Factory.createProduct(&#x27;C&#x27;); productC.getInformation(); &#125;&#125; 二. 工厂方法模式1. 概念工厂方法模式又称为多态性工厂模式。它有多个工厂类和一个产品抽象类。完全实现了开闭原则。一个工厂只生产一个产品。客户不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建。 在工厂方法模式中，核心的工厂类提取成为一个抽象工厂类，由对应产品的子类工厂负责创建对应的产品类对象。抽象工厂类只负责定义子类工厂需要实现的接口，不涉及具体产品类实例化的细节。 2. 角色类 抽象工厂类。工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。定义工厂类的方法，用来创建产品类。在Java中由抽象类或接口实现。 具体工厂类。实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑。用于创建对应的产品对象。 抽象产品类。定义产品公有的属性、方法。在Java中由抽象类或接口实现。 具体产品类。实现对应产品类的属性、方法。3. 实例 *抽象产品类**1234567package FactoryMethod;public interface Product &#123; void getInformation();&#125; *具体产品类A、B**12345678package FactoryMethod;public class ProductA implements Product&#123; public void getInformation() &#123; System.out.println(&quot;产品A&quot;); &#125;&#125; 12345678package FactoryMethod;public class ProductB implements Product&#123; public void getInformation() &#123; System.out.println(&quot;产品B&quot;); &#125;&#125; *抽象工厂类**12345678910package FactoryMethod;import SimpleFactory.Product;public interface Factory &#123; Product createProduct();&#125; *具体工厂类A、B**12345678package FactoryMethod;public class FactoryA implements Factory &#123; public Product createProduct() &#123; return new ProductA(); &#125;&#125; 12345678package FactoryMethod;public class FactoryB implements Factory &#123; public Product createProduct() &#123; return new ProductB(); &#125;&#125; *测试**12345678910111213141516package FactoryMethod;public class Consumer &#123; public static void main(String[] args)&#123; Factory factoryA = new FactoryA(); Product productA = factoryA.createProduct(); productA.getInformation(); Factory factoryB = new FactoryB(); Product productB = factoryB.createProduct(); productB.getInformation(); &#125;&#125; 三. 抽象工厂模式1. 概念抽象工厂模式又称为工具箱模式。它有多个工厂类和多个产品类。不符合开闭原则。一个工厂可以生产一组产品。提供一个创建一系列或相互依赖的对象的接口，而无需指定它们具体的类。缺点： 添加新的产品对像时，难以扩展抽象工厂以便生产新种类的产品。区别： 抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的（同属于同一个产品族的产品是在一起使用的），而工厂方法中的工厂是生产单一产品的工厂。 2. 角色类 抽象工厂类。抽象工厂模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。在Java中由抽象类或接口实现。 具体工厂类。实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑。用于创建对应的产品对象。 抽象产品类。定义产品公有的属性、方法。在Java中由抽象类或接口实现。 具体产品类。抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品。3.实例 *抽象产品类A、B**123456package AbstractFactory;public interface ProductA &#123;&#125; 123456package AbstractFactory;public interface ProductB &#123;&#125; *具体产品类A1、A2、B1、B2**12345678package AbstractFactory;public class ProductA1 implements ProductA &#123; public ProductA1()&#123; System.out.println(&quot;产品A1&quot;); &#125;&#125; 12345678package AbstractFactory;public class ProductA2 implements ProductA &#123; public ProductA2()&#123; System.out.println(&quot;产品A2&quot;); &#125;&#125; 12345678package AbstractFactory;public class ProductB1 implements ProductB &#123; public ProductB1()&#123; System.out.println(&quot;产品B1&quot;); &#125;&#125; 12345678package AbstractFactory;public class ProductB2 implements ProductB &#123; public ProductB2()&#123; System.out.println(&quot;产品B2&quot;); &#125;&#125; *抽象工厂类**12345678package AbstractFactory;public interface Factory &#123; ProductA createProductA(); ProductB createProductB();&#125; *具体工厂类1、2**12345678910111213141516package AbstractFactory;/** * @ClassName: FactoryA * @Description: 生成产品A1、B1 */public class Factory1 implements Factory &#123; public ProductA createProductA() &#123; return new ProductA1(); &#125; public ProductB createProductB() &#123; return new ProductB1(); &#125;&#125; 12345678910111213141516package AbstractFactory;/** * @ClassName: Factory2 * @Description: 生成产品A2、B2 */public class Factory2 implements Factory &#123; public ProductA createProductA() &#123; return new ProductA2(); &#125; public ProductB createProductB() &#123; return new ProductB2(); &#125;&#125; *测试**123456789101112131415package AbstractFactory;public class Consumer &#123; public static void main(String [] args)&#123; Factory1 factory1 = new Factory1(); factory1.createProductA(); factory1.createProductB(); Factory2 factory2 = new Factory2(); factory2.createProductA(); factory2.createProductB(); &#125;&#125; *文章代码已上传至Github**","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.subarashii.top/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.subarashii.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringBoot系列日志配置","slug":"SpringBoot系列日志配置","date":"2019-08-01T08:22:47.000Z","updated":"2019-08-28T02:41:00.000Z","comments":true,"path":"2019/08/01/SpringBoot系列日志配置/","link":"","permalink":"http://www.subarashii.top/2019/08/01/SpringBoot%E7%B3%BB%E5%88%97%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/","excerpt":"","text":"导入 Maven 包SpringBoot 默认使用了 LogBack 日志系统，所以如无需求是没有必要改为其他日志系统的，也无需再进行多余的配置，LogBack 默认将日志打到控制台上。 当我们新建 SpringBoot 项目时，Maven 会自动引用 spring-boot-starter 或 spring-boot-starter-web，而这两个起步依赖中已经包含了对于 spring-boot-starter-logging 的依赖，所以无需再额外添加日志系统依赖，开箱即用。 但在这里，为了方便使用日志，我们将导入 Slf4j 和 Lombok 12345678910111213&lt;!--@Slf4j需导入lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.26&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 注： 要使用 @Slf4j 注解需要导入 Lombok 插件，而使用 Lombok 插件需要 IDEA 安装该插件。 image.png 配置 在 resource 文件夹下新建 log 文件夹，并在其下新建 logback.xml 文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;!-- Logback configuration. See http://logback.qos.ch/manual/index.html --&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt; &lt;!--继承spring boot提供的logback配置--&gt; &lt;!--&lt;include resource=&quot;org/springframework/boot/logging/logback/base.xml&quot; /&gt;--&gt; &lt;!--设置系统日志目录--&gt; &lt;property name=&quot;APP_DIR&quot; value=&quot;spring-boot-log&quot;/&gt; &lt;!-- 彩色日志 --&gt; &lt;!-- 彩色日志依赖的渲染类 --&gt; &lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot;/&gt; &lt;conversionRule conversionWord=&quot;wex&quot; converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;/&gt; &lt;conversionRule conversionWord=&quot;wEx&quot; converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;/&gt; &lt;!-- 彩色日志格式 --&gt; &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;Pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;info&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 DEBUG 日志 --&gt; &lt;appender name=&quot;DEBUG_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/log_debug.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 归档的日志文件的路径，例如今天是2017-04-26日志，当前写的日志文件路径为file节点指定，可以将此文件与file指定文件路径设置为不同路径，从而将当前日志文件或归档日志文件置不同的目录。 而2017-04-26的日志文件在由fileNamePattern指定。%d&#123;yyyy-MM-dd&#125;指定日期格式，%i指定索引 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/debug/log-debug-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;!-- 除按日志记录之外，还配置了日志文件不能超过500M，若超过500M，日志文件会以索引0开始， 命名日志文件，例如log-error-2017-04-26.0.log --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;500MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录debug级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;debug&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 INFO 日志 --&gt; &lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/log_info.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 归档的日志文件的路径，例如今天是2017-04-26日志，当前写的日志文件路径为file节点指定，可以将此文件与file指定文件路径设置为不同路径，从而将当前日志文件或归档日志文件置不同的目录。 而2017-04-26的日志文件在由fileNamePattern指定。%d&#123;yyyy-MM-dd&#125;指定日期格式，%i指定索引 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;!-- 除按日志记录之外，还配置了日志文件不能超过500M，若超过500M，日志文件会以索引0开始， 命名日志文件，例如log-error-2017-04-26.0.log --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;500MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录info级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;info&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 WARN 日志 --&gt; &lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/log_warn.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 归档的日志文件的路径，例如今天是2017-04-26日志，当前写的日志文件路径为file节点指定，可以将此文件与file指定文件路径设置为不同路径，从而将当前日志文件或归档日志文件置不同的目录。 而2017-04-26的日志文件在由fileNamePattern指定。%d&#123;yyyy-MM-dd&#125;指定日期格式，%i指定索引 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;!-- 除按日志记录之外，还配置了日志文件不能超过500M，若超过500M，日志文件会以索引0开始， 命名日志文件，例如log-error-2017-04-26.0.log --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;500MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录warn级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;warn&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt; &lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 正在记录的日志文件的路径及文件名 --&gt; &lt;file&gt;$&#123;LOG_PATH&#125;/log_error.log&lt;/file&gt; &lt;!--日志文件输出格式--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- 归档的日志文件的路径，例如今天是2017-04-26日志，当前写的日志文件路径为file节点指定，可以将此文件与file指定文件路径设置为不同路径，从而将当前日志文件或归档日志文件置不同的目录。 而2017-04-26的日志文件在由fileNamePattern指定。%d&#123;yyyy-MM-dd&#125;指定日期格式，%i指定索引 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_PATH&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;!-- 除按日志记录之外，还配置了日志文件不能超过500M，若超过500M，日志文件会以索引0开始， 命名日志文件，例如log-error-2017-04-26.0.log --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;500MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;!--日志文件保留天数--&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- 此日志文件只记录ERROR级别的 --&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;error&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;logger name=&quot;org.springframework.web&quot; level=&quot;info&quot;/&gt; &lt;logger name=&quot;org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor&quot; level=&quot;INFO&quot;/&gt; &lt;!--name为当前工程的java代码的完整目录--&gt; &lt;logger name=&quot;com.sakura.anima&quot; level=&quot;debug&quot;/&gt; &lt;!--开发环境:打印控制台--&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;appender-ref ref=&quot;DEBUG_FILE&quot;/&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot;/&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot;/&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot;/&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!--测试环境:打印控制台和输出到文件--&gt; &lt;springProfile name=&quot;test&quot;&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot;/&gt; &lt;appender-ref ref=&quot;WARN_FILE&quot;/&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot;/&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!--生产环境:输出到文件--&gt; &lt;springProfile name=&quot;prod&quot;&gt; &lt;root level=&quot;error&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;appender-ref ref=&quot;DEBUG_FILE&quot;/&gt; &lt;appender-ref ref=&quot;INFO_FILE&quot;/&gt; &lt;appender-ref ref=&quot;ERROR_FILE&quot;/&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 配置 application.yml1234567#日志logging: #日志配置文件位置 config: classpath:log/logback.xml #日志打印位置，这里是默认在项目根路径下 path: log/spring-boot-log 注：以上是比较详尽的配置，如果不需要，可直接在 application.xml 下进行如下配置，此时可无需配置 logback.xml 12345678910#日志logging: #日志打印位置，这里是默认在项目根路径下 path: log/spring-boot-log #日志文件名，默认为spring.log，和logging.path不同时生效 file: mylog.log #亦可配置指定的日志输出级别 level: root: info 开始使用12345678910111213@RestController@Slf4jpublic class IndexController &#123; @RequestMapping(value = &quot;/&quot;) public String index()&#123; log.info(&quot;使用日志&quot;); return &quot;hello world&quot;; &#125;&#125; image.png 如上，在类上添加 @Slf4j 注解就可以直接使用日志","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://www.subarashii.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.subarashii.top/tags/SpringBoot/"}]},{"title":"SpringBoot系列整合Redis做缓存","slug":"SpringBoot系列整合Redis做缓存","date":"2019-07-31T03:49:44.000Z","updated":"2019-08-28T02:41:11.000Z","comments":true,"path":"2019/07/31/SpringBoot系列整合Redis做缓存/","link":"","permalink":"http://www.subarashii.top/2019/07/31/SpringBoot%E7%B3%BB%E5%88%97%E6%95%B4%E5%90%88Redis%E5%81%9A%E7%BC%93%E5%AD%98/","excerpt":"","text":"一. 缓存的作用当应用体积大了，用户量上去了，数据规模也越来越大之后，数据库查询操作将成为用户体验的瓶颈，这时使用缓存会是一个非常好的解决办法。Spring 开始从3.1 开始就为我们提供了基于注解的缓存支持，通过注解方式低侵入地为我们的应用提供缓存支持。在SpringBoot中，更是以一系列自动配置的方式使我们能更加方便的使用缓存功能。 二. 几个重要的注解 名称 解释 @EnableCaching 开启缓存注解 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @CachePut 保证方法被调用，又希望结果被缓存。 与@Cacheable区别在于是否每次都调用方法，常用于新增、更新 @CacheEvict 清空缓存 三. @Cacheeable/@CachePut/@CacheEvict 的几个常用参数 名称 解释 示例 value 缓存块的名称，必须指定一个 @Cacheable(value = &quot; default &quot;) key 缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合 @Cacheable(value = &quot; default &quot;,key = &quot; &#39;info&#39; &quot;) @Cacheable(value = &quot; default &quot;,key = &quot; #id &quot;) sync (@Cacheable) 指示底层将缓存锁住，使只有一个线程可以进入计算，而其他线程堵塞，直到返回结果更新到缓存中。 可以避免缓存击穿 @Cacheable(value = &quot; default &quot;,sync = true) allEntries (@CacheEvict ) 是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存 @CachEvict(value = ” default ”,allEntries = true) 四. 开始使用 – 整合 Redis注： 需先启动 Redis 服务器 1. 导入 Maven 包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2. 配置 application.yml12345678910111213141516171819202122spring: redis: #指定Redis数据库索引，在redis-cli中使用select index切换数据库 database: 0 #Redis服务器地址 host: 127.0.0.1 #Redis连接端口，默认为 6379 port: 6379 #Redis连接密码，默认为空 password: #连接超时时间 timeout: 0 #连接池 pool: #最大连接数（使用负值表示没有限制） max-acive: 1000 #最大阻塞等待时间 max-wait: -1 #最大空闲连接 max-idle: 10 #最小空闲连接 min-idle: 2 3. 在启动类上开启缓存注解123456789@SpringBootApplication@EnableCaching // 开启缓存注解public class AnimaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AnimaApplication.class, args); &#125;&#125; 4. 缓存 @Cacheable@Cacheable注解会先查询是否已经有缓存，有会使用缓存，没有则会执行方法并缓存。该注解还可预防缓存穿透。 12345678/** * key:可使用参数时，即 key#参数名，亦可直接使用字符串‘key’ * sync：避免缓存击穿 */@Cacheable(value = &quot;default&quot;,key = &quot; &#x27;anima&#x27; + #page&quot;,sync = true)public ArrayList&lt;animaInfo&gt; getAnimaInfo(int page,int limit) &#123; return animaInfoMapper.selectAnima(page,limit);&#125; 注：@Cacheable不支持设置缓存过期时间和自动更新 5. 更新 @CachePut@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。 1234@CachePut(value = &quot;default&quot;,key = &quot; &#x27;anima&#x27; + #anima.id&quot;)public int save(Anima anima) &#123; return animaInfoMapper.saveAnima(anima);&#125; 6. 清除 @CacheEvictallEntries参数表示是否需要清除缓存中的所有元素。默认为false，表示不需要。当指定了allEntries为true时，Spring Cache将忽略指定的key。有的时候我们需要Cache一下清除所有的元素。 1234@CacheEvict(value = &quot;default&quot;,allEntries = true)public int del(Anima anima) &#123; return animaInfoMapper.delAnima(anima.id);&#125;","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://www.subarashii.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.subarashii.top/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://www.subarashii.top/tags/Redis/"}]},{"title":"SpringBoot系列整合Druid数据库连接池","slug":"SpringBoot系列整合Druid数据库连接池","date":"2019-07-30T03:00:44.000Z","updated":"2019-08-28T02:41:20.000Z","comments":true,"path":"2019/07/30/SpringBoot系列整合Druid数据库连接池/","link":"","permalink":"http://www.subarashii.top/2019/07/30/SpringBoot%E7%B3%BB%E5%88%97%E6%95%B4%E5%90%88Druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"","text":"概念数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。（摘自百度百科） 说白了，就是可以重复使用同一个数据库连接，不再需要进行打开、关闭连接,一切都交由数据库连接池去处理，一般可搭配 Mybatis 食用。 配置导入 Maven 包12345&lt;properties&gt; &lt;mysql.connector.version&gt;5.1.47&lt;/mysql.connector.version&gt; &lt;mybatis-spring-boot-starter.version&gt;2.1.0&lt;/mybatis-spring-boot-starter.version&gt; &lt;druid-version&gt;1.1.19&lt;/druid-version&gt;&lt;/properties&gt; 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring-boot-starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.connector.version&#125;&lt;/version&gt; &lt;!--&lt;scope&gt;runtime&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置数据源这里使用的yml的配置方式，如需配置多数据源可以参考这里 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#数据库设置spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/anima?characterEncoding=utf-8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;useSSL=false username: root password: 3333 # 使用Druid数据源 type: com.alibaba.druid.pool.DruidDataSource # 下面为连接池的补充设置，应用到上面所有数据源中 druid: # 初始化大小，最小，最大 initialSize: 5 minIdle: 5 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 2000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 600000 maxEvictableIdleTimeMillis: 900000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql将无法统计，&#x27;wall&#x27;用于防火墙 filters: stat, wall, log4j # 通过connectProperties属性来打开mergeSql功能，慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 #asyncInit是1.1.4中新增加的配置，如果有INITIALSIZE数量较多时，打开会加快应用启动时间 asyncInit: truemybatis: #实体类地址 type-aliases-package: com.sakura.anima.entity mapper-locations: classpath:mapper/*.xml # 开启驼峰匹配 mapUnderscoreToCamelCase: true 这样配置好后启动应用，连接池就会生效了。但是这样还不能使用 Druid 的监控 配置监控123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.sakura.anima.config;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.HashMap;import java.util.Map;/** * @Author: yujianhao * @ClassName: druidConfig * @Description: 配置 Druid 监控 * @CreateDate: 2019-07-30 09:15 */@Configurationpublic class druidConfig &#123; @Bean public ServletRegistrationBean druidServlet() &#123; ServletRegistrationBean reg = new ServletRegistrationBean(); reg.setServlet(new StatViewServlet()); reg.addUrlMappings(&quot;/druid/*&quot;); //设置控制台管理用户 reg.addInitParameter(&quot;loginUsername&quot;,&quot;admin&quot;);// 用户名 reg.addInitParameter(&quot;loginPassword&quot;,&quot;3333&quot;);// 密码 // 禁用HTML页面上的“Reset All”功能 reg.addInitParameter(&quot;resetEnable&quot;,&quot;false&quot;);// reg.addInitParameter(&quot;allow&quot;, &quot;127.0.0.1&quot;); // 白名单// reg.addInitParameter(&quot;deny&quot;,&quot;&quot;); // 黑名单 return reg; &#125; @Bean public FilterRegistrationBean filterRegistrationBean() &#123; //创建过滤器 FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new WebStatFilter()); Map&lt;String, String&gt; initParams = new HashMap&lt;String, String&gt;(); //忽略过滤的形式 initParams.put(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*&quot;); filterRegistrationBean.setInitParameters(initParams); //设置过滤器过滤路径 filterRegistrationBean.addUrlPatterns(&quot;/*&quot;); return filterRegistrationBean; &#125;&#125; 最后在浏览器输入http://localhost:8080/druid就可以使用 Druid 的监控了，用户名、密码就是上面配置的那个。 测试按照上面的配置虽然已经可以生效了，但具体有没有效果我们还不知道，接下来就来试试看性能如何。 查询服务首先写一个简单查询数据库的服务 1234567891011@Override public void testDB() &#123; int num = 0; while (num &lt; 1000)&#123; System.out.println(&quot;第 &quot; + num + &quot; 次 ===&gt; &quot; + animaInfoMapper.selectByPrimaryKey(1)); num++; &#125; &#125; 测试用例123456789101112131415161718192021222324252627282930313233343536373839package com.sakura.anima.service;import com.sakura.anima.AnimaApplication;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.Date;/** * @Author: yujianhao * @ClassName: getInfoServiceTest * @Description: 测试查询数据库用时 * @CreateDate: 2019-07-29 15:55 *///需要注意：如果我们使用的是JUnit 4 ，那么需要添加@RunWith(SpringRunner.class)否则所有注解将会被忽略。//如果你使用的是JUnit5 ,那么在 SpringBootTest 上没有必要添加 @ExtendWith,因为@…Test已经添加了ExtendWith@RunWith(SpringRunner.class)@SpringBootTest(classes=&#123;AnimaApplication.class&#125;)public class getInfoServiceTest &#123; @Autowired getInfoService getInfoService; @Test public void testDB() &#123; Date date1 = new Date(); getInfoService.testDB(); Date date2 = new Date(); System.out.println(&quot;用时：&quot; + (date2.getTime() - date1.getTime()) + &quot; ms&quot;); &#125;&#125; 开始测试由于 Mybatis 是自带有连接池，所以我们就先来看看自带的连接池性能如何。当然application.yml也得做相应的修改 12345678910111213141516#数据库设置spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/anima?characterEncoding=utf-8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;useSSL=false username: root password: 3333mybatis: #实体类地址 type-aliases-package: com.sakura.anima.entity mapper-locations: classpath:mapper/*.xml # 开启驼峰匹配 mapUnderscoreToCamelCase: true image.png 测试五次的最快时间是1736ms 再来看看不使用连接池的性能 1234567891011121314151617#数据库设置spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/anima?characterEncoding=utf-8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;useSSL=false username: root password: 3333 # 不使用连接池 type: com.mysql.jdbc.jdbc2.optional.MysqlConnectionPoolDataSourcemybatis: #实体类地址 type-aliases-package: com.sakura.anima.entity mapper-locations: classpath:mapper/*.xml # 开启驼峰匹配 mapUnderscoreToCamelCase: true image.png 测试五次的最快时间是5268ms，大部分时间应该是花费在了连接、关闭数据库上。 最后再来看看使用 Druid 的性能如何 这里 yml 不需要改动，只需和刚才一开始配置的一样就行 image.png 测试五次的最快时间1511ms，还是比 Mybatis 自带的连接池快上那么一丢丢。阿里的东西就是好用","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://www.subarashii.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.subarashii.top/tags/SpringBoot/"}]},{"title":"JVM学习笔记内存区域","slug":"JVM学习笔记内存区域","date":"2019-07-28T06:43:21.000Z","updated":"2019-08-03T03:20:32.000Z","comments":true,"path":"2019/07/28/JVM学习笔记内存区域/","link":"","permalink":"http://www.subarashii.top/2019/07/28/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"最近在看点JVM的东西，看到JVM的内存区域就做了点笔记。 运行时数据区域先来看看虚拟机的内存区域的基本组成吧。 JDK1.8之前：JVM运行时数据区域.png JDK1.8以后：20193Java运行时数据区域JDK1.8.png 其中，内存区域主要分为线程私有和线程共享。 线程私有： 程序计数器 虚拟机栈 本地方法栈 线程共享： 堆（heap） 方法区 直接内存（非运行时数据区域的一部分） 程序计数器程序计数器在虚拟机中占用内存较小，相当于当前线程在执行字节码文件的行号指示器，类似于调试时语句的执行步骤。 注 程序计数器是虚拟机中唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期和线程一样，随线程的创建而创建，消亡而消亡。 虚拟机栈通常我们说的栈内存，指的就是虚拟机栈（或者说当中的局部变量部分） 它描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。 虚拟机栈是由一个个栈帧组成的，每个栈帧都拥有一个局部变量表（存放基本类型和对象引用）、操作数栈、动态链、方法出口信息。 虚拟机栈的生命周期和线程相同，会出现OutOfMemoryError和StackOverFlowError两种异常。 OutOfMemoryError：若虚拟机栈的内存大小不允许扩展，当线程请求栈的深度超过当前虚拟机栈的最大深度时，则抛出该异常。 StackOverFlowError：若虚拟机的内存大小运行动态扩展，且当线程请求栈时内存刚好用完了，无法再进行动态扩展，这时就会抛出该异常。 本地方法栈与虚拟机栈相似，不同的是： 虚拟机栈是为虚拟机执行Java方法（字节码）服务的 本地方法栈是为虚拟机使用到的Native方法（虚拟机底层的方法，C语言编写，可以访问操作系统底层信息）服务的 本地方法栈同样会有栈帧，其存放的东西与虚拟机栈相同（面向的是本地方法），在HotSpot虚拟机（Sun JDK和OpenJDK中所带的虚拟机）实现中是把本地方法栈和虚拟机栈合二为一的 也会出现OutOfMemoryError和StackOverFlowError两种异常。 堆（heap）堆作为线程共享的区域，在虚拟机中占用的内存是最大的，它的生命周期和虚拟机相同，随着虚拟机的启动而创建，用于存放对象实例和数组内存，是垃圾收集器管理的主要区域。 方法区方法区是用于存储已被虚拟机加载过的类信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池用于存放编译期生成的各种字面量和符号引用。 26038433.jpg 其作为方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存是便会抛出OutOfMemoryError异常。 直接内存直接内存并不属于虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。 以上就是看完资料后做的一些笔记，鉴于原文后面的东西我现在也看不太懂，便不做记录，日后能力提升了再做记录吧。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.subarashii.top/tags/Java/"}]},{"title":"Mybatis动态SQL含运算语句","slug":"Mybatis动态SQL含运算语句","date":"2019-07-25T04:01:19.000Z","updated":"2019-08-28T02:41:34.000Z","comments":true,"path":"2019/07/25/Mybatis动态SQL含运算语句/","link":"","permalink":"http://www.subarashii.top/2019/07/25/Mybatis%E5%8A%A8%E6%80%81SQL%E5%90%AB%E8%BF%90%E7%AE%97%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"最近在一个小项目中用到分页，网上找到一条MySQL分页的公式 12345int page; //page为当前页int pageSize; //pageSize为每页数量//limit m, n 表示从第几条开始检索，查询多少条记录select * from table limit (page - 1)*page , pageSize; 看起来好像很简单，稍微改下mapper文件就行 12//当参数超过一个时，需使用 @Param 标注ArrayList&lt;animaInfo&gt; selectAnima(@Param(&quot;page&quot;) int page, @Param(&quot;pageSize&quot;) int pageSize); 123456&lt;select id=&quot;selectAnima&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from anima_info limit (#&#123;page&#125; - 1) * #&#123;page&#125;, #&#123;pageSize&#125;&lt;/select&gt; 保存、部署、运行一气呵成 123456789102019-08-01 11:35:23.260 ERROR 7152 --- [p-nio-80-exec-2] o.a.c.c.C.[.[.[&#x2F;].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.jdbc.BadSqlGrammarException: ### Error querying database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;(1 - 1) * 1, 10&#39; at line 6### The error may exist in file [F:\\Test\\anima\\target\\classes\\mapper\\animaInfoMapper.xml]### The error may involve defaultParameterMap### The error occurred while setting parameters### SQL: select id, anima_name, season, chapter, anima_link, watch_time, watch_status from anima_info limit (? - 1) * ?, ?### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;(1 - 1) * 1, 10&#39; at line 6; bad SQL grammar []; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;(1 - 1) * 1, 10&#39; at line 6] with root cause あれ，居然出问题了 解决方案 赶紧查找大佬博客资料，好像Mybatis不能执行这种含有运算符的语句，有点坑。 知道问题就好办了，继续查找。 发现了一个标签&lt;bind&gt;,可以使用 OGNL 表达式创建一个变量井将其绑定到上下文中。 继续改改，试试 123456789&lt;select id=&quot;selectAnima&quot; resultMap=&quot;BaseResultMap&quot;&gt; &lt;bind name=&quot;num&quot; value=&quot;(page - 1) * limit&quot; /&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from anima_info limit #&#123;num&#125; , #&#123;pageSize&#125; &lt;/select&gt; image.png 很好，完美运行","categories":[],"tags":[{"name":"小坑","slug":"小坑","permalink":"http://www.subarashii.top/tags/%E5%B0%8F%E5%9D%91/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://www.subarashii.top/tags/Mybatis/"},{"name":"教程","slug":"教程","permalink":"http://www.subarashii.top/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"网页样式不见了","slug":"网页样式不见了","date":"2019-07-24T03:10:48.000Z","updated":"2020-10-24T14:03:40.000Z","comments":true,"path":"2019/07/24/网页样式不见了/","link":"","permalink":"http://www.subarashii.top/2019/07/24/%E7%BD%91%E9%A1%B5%E6%A0%B7%E5%BC%8F%E4%B8%8D%E8%A7%81%E4%BA%86/","excerpt":"","text":"在一个Spring Boot项目中，将HTML文件放到templates文件夹里有一个好处，可以在Controller里直接返回HTML文件的文件名 123456789@Controller@RequestMapping(&quot;/anima&quot;)public class animaController &#123; @RequestMapping(&quot;/index&quot;) public String getIndex()&#123; return &quot;index&quot;; &#125;&#125; 但是如果直接将HTML文件扔到templates里是不行的，这样将导致浏览器找不到css和js文件。 解决方案 可以将HTML文件放到templates里，js和css文件放到static文件夹 image.png 然后修改HTML文件里的引用路径 &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/index.css&quot;&gt;&lt;script src=&quot;/js/index.js&quot;&gt;&lt;/script&gt; 注 /表示的是static文件夹","categories":[],"tags":[{"name":"小坑","slug":"小坑","permalink":"http://www.subarashii.top/tags/%E5%B0%8F%E5%9D%91/"}]},{"title":"SpringBoot系列使用Generator进行自动生成","slug":"SpringBoot系列使用Generator进行自动生成","date":"2019-07-24T01:49:24.000Z","updated":"2019-08-28T02:41:44.000Z","comments":true,"path":"2019/07/24/SpringBoot系列使用Generator进行自动生成/","link":"","permalink":"http://www.subarashii.top/2019/07/24/SpringBoot%E7%B3%BB%E5%88%97%E4%BD%BF%E7%94%A8Generator%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/","excerpt":"","text":"Maven导入Generator插件properties标签下配置版本信息 12&lt;mybatis-generator-maven-plugin.version&gt;1.3.7&lt;&#x2F;mybatis-generator-maven-plugin.version&gt;&lt;mybatis-generator-core.version&gt;1.3.7&lt;&#x2F;mybatis-generator-core.version&gt; build标签下配置导入Generator，不可在dependencies标签下配置 12345678910111213141516171819202122232425262728293031323334353637383940&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt; &lt;&#x2F;resource&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;true&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;!-- MyBatis 逆向工程,自动生成entity、mapper文件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mybatis-generator-maven-plugin.version&#125;&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;project.basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml&lt;&#x2F;configurationFile&gt; &lt;verbose&gt;true&lt;&#x2F;verbose&gt; &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt; &lt;&#x2F;configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mybatis-generator-core.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt; 配置Generator文件在resources目录新建generatorConfig.properties和generatorConfig.xml两个文件 整体目录结构如下 generatorConfig.properties 123456789#数据库驱动jar,必须配对路径drive.class.path &#x3D; F:&#x2F;Test&#x2F;mysql-connector-java-5.1.47.jar# 数据库连接参数jdbc.driver &#x3D; com.mysql.jdbc.Driverjdbc.url &#x3D; jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;anima?characterEncoding&#x3D;utf-8&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;useSSL&#x3D;falsejdbc.username &#x3D; rootjdbc.password&#x3D; 3333 generatorConfig.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;properties resource&#x3D;&quot;generatorConfig.properties&quot; &#x2F;&gt; &lt;!--mysql 连接数据库jar 这里选择自己本地位置--&gt; &lt;classPathEntry location &#x3D; &quot;$&#123;drive.class.path&#125;&quot; &#x2F;&gt; &lt;context id&#x3D;&quot;mybatisGenerator&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name&#x3D;&quot;suppressAllComments&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass&#x3D;&quot;$&#123;jdbc.driver&#125;&quot; connectionURL&#x3D;&quot;$&#123;jdbc.url&#125;&quot; userId&#x3D;&quot;$&#123;jdbc.username&#125;&quot; password&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&gt; &lt;&#x2F;jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaTypeResolver&gt; &lt;!--配置生成的实体包 targetPackage：生成的实体包位置，默认存放在src目录下 targetProject：目标工程名 --&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage&#x3D;&quot;com.sakura.anima.entity&quot; targetProject&#x3D;&quot;.\\src\\main\\java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;javaModelGenerator&gt; &lt;!-- 实体包对应映射文件位置及名称，默认存放在src目录下 --&gt; &lt;sqlMapGenerator targetPackage&#x3D;&quot;mapper&quot; targetProject&#x3D;&quot;.\\src\\main\\resources&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot; targetPackage&#x3D;&quot;com.sakura.anima.mapper&quot; targetProject&#x3D;&quot;.\\src\\main\\java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName&#x3D;&quot;anima_info&quot; domainObjectName&#x3D;&quot;animaInfo&quot; enableDeleteByExample&#x3D;&quot;false&quot; enableSelectByExample&#x3D;&quot;false&quot; enableCountByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot; enableUpdateByPrimaryKey&#x3D;&quot;false&quot;&gt; &lt;!--&lt;generatedKey column&#x3D;&quot;sid&quot; sqlStatement&#x3D;&quot;$&#123;table.primaryKey&#125;&quot;&#x2F;&gt;--&gt; &lt;!-- 需要忽略的列true 大小写完全匹配，false 忽略大小写匹配 --&gt; &lt;!--&lt;ignoreColumn column&#x3D;&quot;PLAN_ID&quot; delimitedColumnName&#x3D;&quot;true&quot; &#x2F;&gt;--&gt; &lt;&#x2F;table&gt; &lt;!--&lt;!&amp;ndash;有些表的字段需要指定java类型&amp;ndash;&gt;--&gt; &lt;!--&lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;userName&quot;&gt;--&gt; &lt;!--&lt;columnOverride column&#x3D;&quot;userName&quot; javaType&#x3D;&quot;String&quot; &#x2F;&gt;--&gt; &lt;!--&lt;&#x2F;table&gt;--&gt; &lt;!--&lt;table schema&#x3D;&quot;&quot; tableName&#x3D;&quot;userName&quot;&gt;--&gt; &lt;!--&lt;columnOverride column&#x3D;&quot;cardId&quot; javaType&#x3D;&quot;Long&quot; &#x2F;&gt;--&gt; &lt;!--&lt;&#x2F;table&gt;--&gt; &lt;&#x2F;context&gt;&lt;&#x2F;generatorConfiguration&gt; 自动生成双击运行该Maven插件即可 小建议 在建表时，表名、字段名称建议用”_”分隔多个单词，比如:ab_cd、cd_e …，这样生成的entity，属性名称就会变成漂亮的驼峰命名，即：abCd、cdE","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://www.subarashii.top/tags/Mybatis/"},{"name":"教程","slug":"教程","permalink":"http://www.subarashii.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.subarashii.top/tags/SpringBoot/"}]},{"title":"缓存穿透缓存雪崩缓存击透的概念及解决方案","slug":"缓存穿透缓存雪崩缓存击透的概念及解决方案","date":"2019-07-23T03:56:49.000Z","updated":"2020-10-24T14:03:26.360Z","comments":true,"path":"2019/07/23/缓存穿透缓存雪崩缓存击透的概念及解决方案/","link":"","permalink":"http://www.subarashii.top/2019/07/23/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%BC%93%E5%AD%98%E5%87%BB%E9%80%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"缓存穿透当客户端频繁地向服务器请求一个缓存中不存在的数据时，服务器会不断查询数据库，数据库可能会因此挂掉。 解决方案 这里有一个简单粗暴的方法。 当查询数据库时，如果结果返回null，这时仍然对其结果进行缓存，但缓存的过期时间很短。 缓存雪崩在设置缓存时都设置了相同的过期时间，致使缓存同时失效，所有请求将全部转发给数据库，数据库瞬时压力过重，导致雪崩。 解决方案 可以在原有的失效时间基础上增加一个随机值，使得每个key的过期时间分散开，不会集中在同一时间段失效。 缓存击穿一个存在的key，在缓存过期的那一刻，刚好有大量的请求，大并发的请求会击穿到DB，造成瞬时DB请求量大，压力骤增。这里的缓存击穿和缓存雪崩看似相同，实际上有一点区别。 击穿是针对某一个 key 雪崩是有很多的 key 同时失效 解决方案 在访问 key 之前，可以采用 SETNX（set if not exists）来设置另一个短期的 key，通过其来锁住当前 key 的访问，访问结束就删除该短期 key。 1234567891011121314151617public String get(key) &#123; String value = redis.get(key); if (value == null) &#123; //代表缓存值过期 //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db if (redis.setnx(key_mutex, 1, 3 * 60) == 1) &#123; //代表设置成功 value = db.get(key); redis.set(key, value, expire_secs); redis.del(key_mutex); &#125; else &#123;//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可 sleep(50); get(key); //重试 &#125; &#125; else &#123; return value; &#125; &#125;","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.subarashii.top/tags/Redis/"}]}],"categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://www.subarashii.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.subarashii.top/tags/SpringCloud/"},{"name":"Java","slug":"Java","permalink":"http://www.subarashii.top/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.subarashii.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.subarashii.top/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://www.subarashii.top/tags/Redis/"},{"name":"小坑","slug":"小坑","permalink":"http://www.subarashii.top/tags/%E5%B0%8F%E5%9D%91/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://www.subarashii.top/tags/Mybatis/"}]}